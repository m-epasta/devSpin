#! sptow v0.2
# Multi-target configuration language
# Syntax: @target>output-format { ... }

# =========== GLOBAL CONFIG ===========
@global {
  version: "1.0"
  name: "my-app"
  description: "My Rust app with services"
  
  # Global variables accessible in all targets
  vars:
    rust_version: "1.75"
    node_version: "20"
    main_port: 8080
    db_port: 5432
    cache_port: 6379
}

# =========== DOCKER TARGET ===========
@target>docker {
  # Metadata
  metadata:
    labels:
      com.spintowin.version: "${global.version}"
      com.spintowin.app: "${global.name}"
  
  # Base image
  from: "rust:${global.vars.rust_version}-slim"
  
  # Build stage
  @stage>builder {
    workdir: "/app"
    
    # System dependencies
    run: |
      apt-get update && apt-get install -y \
        git \
        curl \
        npm \
        openssl \
        pkg-config \
        && rm -rf /var/lib/apt/lists/*
    
    # Copy and build
    copy: ["Cargo.toml", "Cargo.lock", "./"]
    run: "cargo build --release"
  }
  
  # Final stage
  @stage>runtime {
    from: "debian:bullseye-slim"
    copy-from: "builder", ["/app/target/release/my-app", "/usr/local/bin/"]
    
    # Expose port
    expose: "${global.vars.main_port}"
    
    # Environment
    env:
      RUST_LOG: "debug"
      PORT: "${global.vars.main_port}"
      DATABASE_URL: "postgres://user:pass@postgres:${global.vars.db_port}/mydb"
    
    # Entrypoint
    cmd: ["/usr/local/bin/my-app"]
  }
  
  # Services (for docker-compose)
  @service>postgres {
    image: "postgres:15"
    ports: ["${global.vars.db_port}:${global.vars.db_port}"]
    environment:
      POSTGRES_USER: "user"
      POSTGRES_PASSWORD: "pass"
      POSTGRES_DB: "mydb"
    volumes: ["pgdata:/var/lib/postgresql/data"]
  }
  
  @service>redis {
    image: "redis:alpine"
    ports: ["${global.vars.cache_port}:${global.vars.cache_port}"]
    command: "redis-server --requirepass pass"
  }
  
  # Volumes
  @volume>pgdata {}
  @volume>redisdata {}
}

# =========== DOCKER-COMPOSE TARGET ===========
@target>docker-compose {
  version: "3.8"
  
  services:
    app:
      build: .
      ports:
        - "${global.vars.main_port}:${global.vars.main_port}"
      environment:
        DATABASE_URL: "postgres://user:pass@postgres:${global.vars.db_port}/mydb"
        REDIS_URL: "redis://:pass@redis:${global.vars.cache_port}"
      depends_on:
        - postgres
        - redis
    
    postgres: @ref>docker.service.postgres
    redis: @ref>docker.service.redis
  
  volumes:
    pgdata: @ref>docker.volume.pgdata
    redisdata: @ref>docker.volume.redisdata
}

# =========== KUBERNETES TARGET ===========
@target>kubernetes {
  # Generate K8s manifests
  @manifest>deployment {
    apiVersion: "apps/v1"
    kind: "Deployment"
    metadata:
      name: "${global.name}"
      labels:
        app: "${global.name}"
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: "${global.name}"
      template:
        spec:
          containers:
            - name: "app"
              image: "${global.name}:latest"
              ports:
                - containerPort: "${global.vars.main_port}"
              envFrom:
                - configMapRef:
                    name: "${global.name}-config"
    
    # This would generate to: k8s/deployment.yaml
  }
  
  @manifest>configmap {
    apiVersion: "v1"
    kind: "ConfigMap"
    metadata:
      name: "${global.name}-config"
    data:
      DATABASE_URL: "postgres://user:pass@postgres:${global.vars.db_port}/mydb"
      REDIS_URL: "redis://:pass@redis:${global.vars.cache_port}"
  }
}

# =========== BASH TARGET (Dev scripts) ===========
@target>bash {
  # Development scripts
  @script>dev {
    #!/bin/bash
    # Generated from SPTOW
    
    echo "ðŸš€ Starting ${global.name} development environment..."
    
    # Start services
    docker-compose up -d postgres redis
    
    # Wait for services
    echo "â³ Waiting for services..."
    sleep 5
    
    # Run the app
    cargo watch -x run
  }
  
  @script>test {
    #!/bin/bash
    
    echo "ðŸ§ª Running tests..."
    
    # Unit tests
    cargo test
    
    # Integration tests (requires services)
    docker-compose up -d
    cargo test --test integration
    
    # Cleanup
    docker-compose down
  }
}

# =========== MAKE TARGET ===========
@target>makefile {
  # Generate a Makefile
  .PHONY: build test run clean
  
  build:
  	@echo "Building ${global.name}..."
  	docker build -t ${global.name}:latest .
  
  test: build
  	@docker-compose run --rm app cargo test
  
  run: build
  	@docker-compose up
  
  clean:
  	@docker-compose down -v
  	@docker rmi ${global.name}:latest || true
}

# =========== TASK RUNNER ===========
# These are NOT transpiled - executed by SPTOW runtime
@task>setup {
  description: "Setup development environment"
  
  steps:
    - name: "Check prerequisites"
      run: |
        which docker || (echo "Docker required" && exit 1)
        which cargo || (echo "Rust required" && exit 1)
    
    - name: "Initialize project"
      run: |
        cargo init
        npm init -y
    
    - name: "Create necessary files"
      # This writes files based on targets above
      action: "generate"
      files:
        - "Dockerfile"
        - "docker-compose.yml"
        - "Makefile"
        - "scripts/dev.sh"
}

@task>deploy {
  description: "Deploy to production"
  depends: ["test"]
  
  steps:
    - name: "Build production image"
      run: "docker build -t myregistry/${global.name}:${global.version} ."
    
    - name: "Push to registry"
      run: "docker push myregistry/${global.name}:${global.version}"
    
    - name: "Deploy to k8s"
      run: "kubectl apply -f k8s/"
      
  environment: "production"
}

# =========== CONDITIONAL SECTIONS ===========
# Only include in specific environments
@if "${env.NODE_ENV == 'production'}" {
  @target>docker {
    @stage>runtime {
      # Production optimizations
      run: |
        apt-get update && apt-get install -y \
          ca-certificates \
          && rm -rf /var/lib/apt/lists/*
        useradd -m appuser
        chown -R appuser:appuser /usr/local/bin/my-app
      user: "appuser"
    }
  }
}

# =========== MACROS/REUSABLE BLOCKS ===========
@macro>healthcheck {
  # Reusable health check definition
  healthcheck:
    test: ["CMD", $1]
    interval: "${$2 || '30s'}"
    timeout: "${$3 || '5s'}"
    retries: ${$4 || 3}
}

@target>docker {
  @service>app {
    # Use the macro
    healthcheck: @macro>healthcheck("curl -f http://localhost:${global.vars.main_port}/health", "10s", "3s", 5)
  }
}