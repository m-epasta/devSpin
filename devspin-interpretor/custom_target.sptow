#! sptow v1.0
# SPTOW configuration with custom targets

# =========== GLOBAL ===========
@global {
  app:
    name: "my-app"
    version: "1.0.0"
    
  env: "${process.env.NODE_ENV || 'development'}"
  region: "${process.env.AWS_REGION || 'us-east-1'}"
}

# =========== USER-DEFINED TARGET TEMPLATE ===========
@template>container {
  # Define parameters
  params:
    name: string
    image: string
    port: number
    env: map[string, any] = {}
  
  # Template for Docker
  @output>docker {
    {{ name }}:
      build: ./{{ name }}
      ports:
        - "{{ port }}:{{ port }}"
      environment:
        {% for key, value in env %}
        {{ key }}: {{ value }}
        {% endfor %}
  }
  
  # Template for Kubernetes
  @output>kubernetes {
    apiVersion: v1
    kind: Service
    metadata:
      name: {{ name }}
    spec:
      ports:
        - port: {{ port }}
      selector:
        app: {{ name }}
  }
  
  # Template for Terraform (AWS ECS)
  @output>terraform {
    resource "aws_ecs_task_definition" "{{ name }}" {
      container_definitions = jsonencode([{
        name = "{{ name }}"
        image = "{{ image }}"
        portMappings = [{
          containerPort = {{ port }}
        }]
        environment = [
          {% for key, value in env %}
          { name = "{{ key }}", value = "{{ value }}" },
          {% endfor %}
        ]
      }])
    }
  }
}

# =========== USE THE TEMPLATE ===========
@target>production {
  # Use the template
  api: @template>container(
    name: "api",
    image: "${global.app.name}:${global.app.version}",
    port: 8080,
    env: {
      NODE_ENV: "production",
      DATABASE_URL: "${secret('DB_URL')}"
    }
  )
  
  worker: @template>container(
    name: "worker",
    image: "${global.app.name}-worker:${global.app.version}",
    port: 3000
  )
}

# =========== PLUGIN SYSTEM ===========
@plugin>aws-lambda {
  # Plugin metadata
  version: "1.0"
  author: "SPTOW Community"
  
  # Define new block types this plugin adds
  blocks:
    - @lambda>NAME
    - @api-gateway>NAME
  
  # Define new functions
  functions:
    arn: "(region, name) => `arn:aws:lambda:${region}:*:function:${name}`"
    invoke_url: "(apiId, stage) => `https://${apiId}.execute-api.${region}.amazonaws.com/${stage}`"
  
  # Templates included with plugin
  templates:
    - @template>lambda-function
    - @template>api-route
}

# Use the plugin
@lambda>process-image {
  runtime: "nodejs18.x"
  handler: "index.handler"
  memory: 1024
  
  # Plugin-specific configuration
  layers:
    - "arn:aws:lambda:${global.region}:123456789012:layer:sharp:1"
  
  events:
    - s3:
        bucket: "uploads"
        events: ["s3:ObjectCreated:*"]
}

# =========== EXTEND EXISTING TARGETS ===========
@extend>docker {
  # Add custom directives to Docker target
  @directive>healthcheck {
    syntax: "HEALTHCHECK [OPTIONS] CMD command"
    
    transpile: |
      HEALTHCHECK --interval={{ interval }} \
                 --timeout={{ timeout }} \
                 --start-period={{ start_period }} \
                 --retries={{ retries }} \
                 CMD {{ command }}
  }
  
  @directive>user {
    syntax: "USER username[:group]"
    
    transpile: |
      USER {{ user }}{% if group %}:{{ group }}{% endif %}
  }
}

# Use extended directives
@target>secure-docker {
  from: "node:18-alpine"
  
  @healthcheck {
    interval: "30s"
    timeout: "3s"
    start_period: "60s"
    retries: 3
    command: "curl -f http://localhost:3000/health || exit 1"
  }
  
  @user {
    user: "node"
    group: "node"
  }
}

# =========== CUSTOM TYPE SYSTEM ===========
@type>DatabaseConfig {
  fields:
    host: string
    port: number
    username: string
    password: string @secret
    database: string
    
  validators:
    - "port > 0 && port < 65536"
    - "host != 'localhost' || env.NODE_ENV == 'development'"
  
  methods:
    url: "() => `postgres://${this.username}:${this.password}@${this.host}:${this.port}/${this.database}`"
}

# Use the custom type
@global {
  db: @type>DatabaseConfig(
    host: "${env.DB_HOST || 'localhost'}",
    port: "${env.DB_PORT || 5432}",
    username: "${env.DB_USER || 'app'}",
    password: "${secret('DB_PASSWORD')}",
    database: "${env.DB_NAME || 'app_db'}"
  )
}

# =========== MACRO SYSTEM ===========
@macro>standard-webapp {
  # Macro with parameters
  params: [name, port = 3000, framework = "express"]
  
  # Expands to multiple targets
  expand: |
    @target>docker {
      {{ name }}:
        build: .
        ports: ["{{ port }}:{{ port }}"]
    }
    
    @target>kubernetes {
      # ... k8s manifest
    }
    
    @task>deploy-{{ name }} {
      run: "kubectl apply -f k8s/{{ name }}.yaml"
    }
}

# Use the macro
@macro>standard-webapp("api", 8080, "fastify")
@macro>standard-webapp("admin", 3000)

# =========== TARGET TRANSFORMATIONS ===========
@transform>docker-to-podman {
  # Convert Docker output to Podman
  match: "@target>docker"
  
  apply: |
    # Replace docker commands with podman
    {{ content | replace("docker-compose", "podman-compose") }}
    {{ content | replace("docker build", "podman build") }}
}

@transform>add-monitoring {
  # Add monitoring to all services
  match: "@service>*"
  
  apply: |
    {{ content }}
    
    # Add Prometheus metrics
    labels:
      prometheus.io/scrape: "true"
      prometheus.io/port: "{{ port }}"
    
    # Add health endpoint
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{{ port }}/health"]
}